#!/bin/awk -f

# TODO
# - Indent assertions
# - Repeatable same checks
# - --running-shell instead of commands
#   - or running executable file?
# - Output equals and equals file
# - Output (colored) diffing
# - Output match trailing newline
# - Exit code ranges
# - Output verification by command
# - Providing standard input to command

# Populate config argument with tool configuration
function init_opts(config, argc, argv) {
  for (i = 1; i < argc; i++) {
    switch (argv[i]) {
      case "--message":
        read_opt_value(config, argv, ++i, CNF_MESSAGE, "--message")
      break;
      case "--exit-with":
        read_opt_value(config, argv, ++i, CNF_EXIT, "--exit-with")
      break;
      case "--succeeds":
        config[CNF_EXIT] = 0
        config[CNF_STDERR] = REGEX_EMPTY
      break;
      case "--succeeds-silently":
        config[CNF_EXIT] = 0
        config[CNF_STDOUT] = REGEX_EMPTY
        config[CNF_STDERR] = REGEX_EMPTY
      break;
      case "--stdout-matches":
        read_opt_value(config, argv, ++i, CNF_STDOUT, "--stdout-matches")
      break;
      case "--no-stdout":
        config[CNF_STDOUT] = REGEX_EMPTY
      break;
      case "--stderr-matches":
        read_opt_value(config, argv, ++i, CNF_STDERR, "--stderr-matches")
      break;
      case "--no-stderr":
        config[CNF_STDERR] = REGEX_EMPTY
      break;
      case "--running":
        read_opt_value(config, argv, ++i, CNF_COMMAND, "--running")
        prepare_exec(config[CNF_COMMAND], config_running_exec)
      break
      default:
        print "Unknown option "argv[i]" given" > "/dev/stderr"
        exit EXIT_USAGE
      break;
    }
  }

  # Print config
  # for (key in config) {
  #   print key": "config[key]
  # }

  if (!(CNF_COMMAND in config)) {
    print "No operation specified. Use --running" > "/dev/stderr"
    exit EXIT_USAGE
  }
}

function read_opt_value(config, argv, value_index, cnf_name, arg_name) {
  if (length(argv) <= value_index) {
    print "Option "arg_name" given with no value" > "/dev/stderr"
    exit EXIT_USAGE
  }
  config[cnf_name] = argv[value_index]
}

# Turn the command specifier into a shell call to run and capture stuff
function prepare_exec(command_specifier, exec_array) {
  new_array(exec_array)
  token = "assert-exec-"(1000000*rand())
  exec_array["stdout"] = "/tmp/assert-exec-"token"-stdout"
  exec_array["stderr"] = "/tmp/assert-exec-"token"-stderr"

  COMMA_SUBSTITUTE="string_never_to_be_found_in_real_input_to_be_used_to_temporarily_hide_quoted_commas_before_splitting"
  gsub(/\\,/, COMMA_SUBSTITUTE, command_specifier)
  split(command_specifier, chunks, ",")
  # Explicitly use empty stdin not to inherit the one from assert itself
  # Otherwise input reading command will halt the execution
  command = ": | exec"
  show_command = ""
  for(ii = 1; ii <= length(chunks); ii++) {
    arg = chunks[ii]
    gsub(COMMA_SUBSTITUTE, ",", arg)
    gsub(/[']/, "'\\''", arg)
    command = command" '"arg"'"
    show_command = show_command"'"arg"' "
  }
  command = command" > '"exec_array["stdout"]"' 2> '"exec_array["stderr"]"'"
  exec_array["command"] = command
  gsub(/[ ]$/, "", show_command) # Remove trailing space
  exec_array["show_command"] = show_command
}

function new_array(array) {
  split("", array)
}

BEGIN {
  EXIT_SUCCESS = 0
  EXIT_USAGE = 1
  EXIT_FAILURE = 2

  CNF_MESSAGE="message"
  CNF_STDOUT="stdout"
  CNF_STDERR="stderr"
  CNF_EXIT="exit"
  CNF_COMMAND="command"

  REGEX_EMPTY="^$"

  # We use rand() down the path so initializing it now. Second resolution of systime()
  # is not sufficient to prevent consecutive invocations of assert to clash on random paths generated
  srand(systime()*PROCINFO["pid"])
  RS="^$" # So we can read whole files easily

  # Tool configuration provided
  new_array(config)
  # ExecArray for main execution task (--running)
  new_array(config_running_exec)
  # Map of problems detected
  new_array(assertions)

  init_opts(config, ARGC, ARGV)

  exit_code = system(config_running_exec["command"])
  if (CNF_EXIT in config && exit_code != config[CNF_EXIT]) {
    v = ("Exit code mismatch. Expected "config[CNF_EXIT]", was "exit_code)
    assertions["exit"] = v
  }

  if (CNF_STDOUT in config) {
    getline out < (config_running_exec["stdout"])
    if (out !~ config[CNF_STDOUT]) {
      v = ("Expected stdout matching '"config[CNF_STDOUT]"', was:\n    "out)
      assertions["stdout"] = v
    }
  }
  system("rm -f '"config_running_exec["stdout"]"'")

  if (CNF_STDERR in config) {
    getline err < (config_running_exec["stderr"])
    if (err !~ config[CNF_STDERR]) {
      v = ("Expected stderr matching '"config[CNF_STDERR]"', was:\n    "err)
      assertions["stderr"] = v
    }
  }
  system("rm -f '"config_running_exec["stderr"]"'")

  if (length(assertions) == 0) exit EXIT_SUCCESS

  print "ASSERT: Failed running: "config_running_exec["show_command"]  > "/dev/stderr"
  for (key in assertions) {
    print "  - "assertions[key] > "/dev/stderr"
  }

  exit EXIT_FAILURE
}
